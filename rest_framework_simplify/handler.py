import logging
from typing import TypedDict

from django.http import Http404, QueryDict
from django.core.exceptions import PermissionDenied
from rest_framework import exceptions, status
from rest_framework.response import Response
from rest_framework.request import Request


class _Context(TypedDict):
    request: Request


def exception_handler(exc: Exception, context: _Context) -> Response:
    """
    exception_handler logs detailed exceptions and returns generic messages to consumers. The
    messages are vague for security reasons.

    Exceptions extending APIException are able to pass through messages with the default_detail
    field and status codes with the status_code field.

    Django's Http404 and PermissionDenied are translated to Rest Framework's NotFound and
    PermissionDenied.

    NotAuthenticated and AuthenticationFailed are coerced to a 403 status.

    Logs generated by the exception_handler may contain sensitive data in the rq_data and
    rq_query_params. This data can be masked with:
    - rest_framework_simplify.decorators.sensitive_rq_data
    - rest_framework_simplify.decorators.sensitive_rq_query_params
    """
    # Historically, 400 has been the default instead of 500.
    status_code = status.HTTP_400_BAD_REQUEST
    error_message = exceptions.APIException.default_detail

    exc = _django_to_rest_framework(exc)

    if isinstance(exc, exceptions.APIException):
        status_code = exc.status_code
        # default_detail is chosen over detail in order to not expose too much information.
        error_message = exc.default_detail

    _log_exception(exc, context, status_code, error_message)

    return Response({ 'errorMessage': error_message }, status=status_code)


REDACT_MESSAGE = f'**Redacted by {exception_handler.__module__}.{exception_handler.__name__}**'


def _django_to_rest_framework(exc: Exception):
    if isinstance(exc, Http404):
        return exceptions.NotFound(*exc.args)
    if isinstance(exc, PermissionDenied):
        return exceptions.PermissionDenied(*exc.args)
    return exc


def _log_exception(exc: Exception, context: _Context, status_code: int, error_message: str):
    logger = logging.getLogger('rest-framework-simplify-exception')
    extra = {
        'rq_query_params': _get_redacted_rq_query_params(exc, context),
        'rq_data': _get_redacted_rq_data(exc, context),
        'rq_method': context['request'].method,
        'rq_path': context['request'].path,
        'rs_status_code': status_code,
        'exc_first_arg': exc.args[0] if exc.args else None,
        'exc_detail': exc.detail if isinstance(exc, exceptions.APIException) else None
    }
    logger.exception(error_message, extra=extra)


def _get_redacted_rq_data(exc: Exception, context: _Context):
    if not hasattr(exc, '_sensitive_rq_data_keys'):
        return context['request'].data
    qd = context['request'].data
    if isinstance(context['request'].data, QueryDict):
        qd = context['request'].data.copy()
    sensitive_keys = [_to_canonical(k) for k in exc._sensitive_rq_data_keys]
    for k in qd.keys():
        if _to_canonical(k) in sensitive_keys:
            qd[k] = REDACT_MESSAGE
    return qd


def _get_redacted_rq_query_params(exc: Exception, context: _Context):
    if not hasattr(exc, '_sensitive_rq_query_params'):
        return context['request'].query_params
    qd = context['request'].query_params.copy()
    sensitive_keys = [_to_canonical(k) for k in exc._sensitive_rq_query_params]
    for k in qd.keys():
        if _to_canonical(k) in sensitive_keys:
            qd[k] = REDACT_MESSAGE
    return qd


# _to_canonical solves the issue of snake case and camel case being supported. By lowering and
# stripping underscores, we cover keys in any format.
def _to_canonical(key):
    return key.replace('_', '').lower()
